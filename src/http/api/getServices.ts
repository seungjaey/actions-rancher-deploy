import type { AxiosInstance } from 'axios';

export interface GetServicesResponse {
  type: string;
  resourceType: string;
  links: {
    self: string;
  };
  createTypes: {
    dnsService: string;
    externalService: string;
    loadBalancerService: string;
    networkDriverService: string;
    service: string;
    storageDriverService: string;
  };
  actions: {};
  data: {
    id: string;
    type: string;
    links: {
      self: string;
      account: string;
      consumedbyservices: string;
      consumedservices: string;
      instances: string;
      networkDrivers: string;
      serviceExposeMaps: string;
      serviceLogs: string;
      stack: string;
      storageDrivers: string;
      containerStats: string;
    };
    actions: {
      upgrade: string;
      restart: string;
      update: string;
      remove: string;
      deactivate: string;
      removeservicelink: string;
      addservicelink: string;
      setservicelinks: string;
    };
    baseType: string;
    name: string;
    state: string;
    accountId: string;
    assignServiceIpAddress: boolean;
    createIndex: number;
    created: string;
    createdTS: number;
    currentScale: number;
    description: any;
    externalId: any;
    fqdn: any;
    healthState: string;
    instanceIds: string[];
    kind: string;
    launchConfig: {
      type: string;
      blkioWeight: any;
      capAdd: any[];
      capDrop: any[];
      cgroupParent: any;
      count: any;
      cpuCount: any;
      cpuPercent: any;
      cpuPeriod: any;
      cpuQuota: any;
      cpuRealtimePeriod: any;
      cpuRealtimeRuntime: any;
      cpuSet: any;
      cpuSetMems: any;
      cpuShares: any;
      dataVolumes: any[];
      dataVolumesFrom: any[];
      description: any;
      devices: any[];
      diskQuota: any;
      dns: any[];
      dnsSearch: any[];
      domainName: any;
      environment: {
        RUN_STAGE: string;
        STAGE: string;
      };
      healthInterval: any;
      healthRetries: any;
      healthTimeout: any;
      hostname: any;
      imageUuid: string;
      instanceTriggeredStop: string;
      ioMaximumBandwidth: any;
      ioMaximumIOps: any;
      ip: any;
      ip6: any;
      ipcMode: any;
      isolation: any;
      kernelMemory: any;
      kind: string;
      labels: {
        'traefik.backend': string;
        'traefik.enable': string;
        'traefik.frontend.rule': string;
        'traefik.port': string;
        'io.rancher.scheduler.affinity:host_label': string;
      };
      logConfig: {
        type: string;
        config: {};
        driver: any;
      };
      memory: any;
      memoryMb: any;
      memoryReservation: any;
      memorySwap: any;
      memorySwappiness: any;
      milliCpuReservation: any;
      networkMode: string;
      oomScoreAdj: any;
      pidMode: any;
      pidsLimit: any;
      ports: any[];
      privileged: boolean;
      publishAllPorts: boolean;
      readOnly: boolean;
      requestedIpAddress: any;
      runInit: boolean;
      secrets: any[];
      shmSize: any;
      startOnCreate: boolean;
      stdinOpen: boolean;
      stopSignal: any;
      stopTimeout: any;
      system: boolean;
      tty: boolean;
      user: any;
      userdata: any;
      usernsMode: any;
      uts: any;
      version: string;
      volumeDriver: any;
      workingDir: any;
      dataVolumesFromLaunchConfigs: any[];
      networkLaunchConfig: any;
      vcpu: number;
      drainTimeoutMs: number;
    };
    lbConfig: any;
    linkedServices: any;
    metadata: {
      'io.rancher.service.hash': string;
    };
    publicEndpoints: any;
    removed: any;
    retainIp: any;
    scale: number;
    scalePolicy: any;
    secondaryLaunchConfigs: any[];
    selectorContainer: any;
    selectorLink: any;
    stackId: string;
    startOnCreate: boolean;
    system: boolean;
    transitioning: string;
    transitioningMessage: any;
    transitioningProgress: any;
    upgrade: {
      type: string;
      inServiceStrategy: {
        type: string;
        batchSize: number;
        intervalMillis: number;
        launchConfig: {
          type: string;
          blkioWeight: any;
          capAdd: any[];
          capDrop: any[];
          cgroupParent: any;
          count: any;
          cpuCount: any;
          cpuPercent: any;
          cpuPeriod: any;
          cpuQuota: any;
          cpuRealtimePeriod: any;
          cpuRealtimeRuntime: any;
          cpuSet: any;
          cpuSetMems: any;
          cpuShares: any;
          dataVolumes: any[];
          dataVolumesFrom: any[];
          description: any;
          devices: any[];
          diskQuota: any;
          dns: any[];
          dnsSearch: any[];
          domainName: any;
          environment: {
            RUN_STAGE: string;
            STAGE: string;
          };
          healthInterval: any;
          healthRetries: any;
          healthTimeout: any;
          hostname: any;
          imageUuid: string;
          instanceTriggeredStop: string;
          ioMaximumBandwidth: any;
          ioMaximumIOps: any;
          ip: any;
          ip6: any;
          ipcMode: any;
          isolation: any;
          kernelMemory: any;
          kind: string;
          labels: {
            'traefik.backend': string;
            'traefik.enable': string;
            'traefik.frontend.rule': string;
            'traefik.port': string;
            'io.rancher.scheduler.affinity:host_label': string;
          };
          logConfig: {
            type: string;
            config: {};
            driver: any;
          };
          memory: any;
          memoryMb: any;
          memoryReservation: any;
          memorySwap: any;
          memorySwappiness: any;
          milliCpuReservation: any;
          networkMode: string;
          oomScoreAdj: any;
          pidMode: any;
          pidsLimit: any;
          ports: any[];
          privileged: boolean;
          publishAllPorts: boolean;
          readOnly: boolean;
          requestedIpAddress: any;
          runInit: boolean;
          secrets: any[];
          shmSize: any;
          startOnCreate: boolean;
          stdinOpen: boolean;
          stopSignal: any;
          stopTimeout: any;
          system: boolean;
          tty: boolean;
          user: any;
          userdata: any;
          usernsMode: any;
          uts: any;
          version: string;
          volumeDriver: any;
          workingDir: any;
          dataVolumesFromLaunchConfigs: any[];
          networkLaunchConfig: any;
          vcpu: number;
          drainTimeoutMs: number;
        };
        previousLaunchConfig: {
          type: string;
          blkioWeight: any;
          capAdd: any[];
          capDrop: any[];
          cgroupParent: any;
          count: any;
          cpuCount: any;
          cpuPercent: any;
          cpuPeriod: any;
          cpuQuota: any;
          cpuRealtimePeriod: any;
          cpuRealtimeRuntime: any;
          cpuSet: any;
          cpuSetMems: any;
          cpuShares: any;
          dataVolumes: any[];
          dataVolumesFrom: any[];
          description: any;
          devices: any[];
          diskQuota: any;
          dns: any[];
          dnsSearch: any[];
          domainName: any;
          environment: {
            RUN_STAGE: string;
            STAGE: string;
          };
          healthInterval: any;
          healthRetries: any;
          healthTimeout: any;
          hostname: any;
          imageUuid: string;
          instanceTriggeredStop: string;
          ioMaximumBandwidth: any;
          ioMaximumIOps: any;
          ip: any;
          ip6: any;
          ipcMode: any;
          isolation: any;
          kernelMemory: any;
          kind: string;
          labels: {
            'traefik.backend': string;
            'traefik.enable': string;
            'traefik.frontend.rule': string;
            'traefik.port': string;
            'io.rancher.scheduler.affinity:host_label': string;
          };
          logConfig: {
            type: string;
            config: {};
            driver: any;
          };
          memory: any;
          memoryMb: any;
          memoryReservation: any;
          memorySwap: any;
          memorySwappiness: any;
          milliCpuReservation: any;
          networkMode: string;
          oomScoreAdj: any;
          pidMode: any;
          pidsLimit: any;
          ports: any[];
          privileged: boolean;
          publishAllPorts: boolean;
          readOnly: boolean;
          requestedIpAddress: any;
          runInit: boolean;
          secrets: any[];
          shmSize: any;
          startOnCreate: boolean;
          stdinOpen: boolean;
          stopSignal: any;
          stopTimeout: any;
          system: boolean;
          tty: boolean;
          user: any;
          userdata: any;
          usernsMode: any;
          uts: any;
          version: string;
          volumeDriver: any;
          workingDir: any;
          dataVolumesFromLaunchConfigs: any[];
          networkLaunchConfig: any;
          vcpu: number;
          drainTimeoutMs: number;
        };
        previousSecondaryLaunchConfigs: any[];
        secondaryLaunchConfigs: any[];
        startFirst: boolean;
      };
      toServiceStrategy: any;
    };
    uuid: string;
    vip: any;
  }[];
  sortLinks: {
    accountId: string;
    createIndex: string;
    created: string;
    description: string;
    externalId: string;
    healthState: string;
    id: string;
    kind: string;
    name: string;
    removeTime: string;
    removed: string;
    selectorContainer: string;
    selectorLink: string;
    skip: string;
    stackId: string;
    state: string;
    system: string;
    uuid: string;
    vip: string;
  };
  pagination: {
    first: any;
    previous: any;
    next: any;
    limit: number;
    total: any;
    partial: boolean;
  };
  sort: any;
  filters: {
    accountId: any;
    createIndex: any;
    created: any;
    description: any;
    externalId: any;
    healthState: any;
    id: any;
    kind: any;
    name: {
      value: string;
      modifier: string;
    }[];
    removeTime: any;
    removed: any;
    selectorContainer: any;
    selectorLink: any;
    skip: any;
    stackId: {
      value: string;
      modifier: string;
    }[];
    state: any;
    system: any;
    uuid: any;
    vip: any;
  };
  createDefaults: {};
}

interface Options {
  stackId: string;
  name: string;
}

export const getServices = async (
  httpClient: AxiosInstance,
  { stackId, name }: Options,
): Promise<GetServicesResponse> => {
  const { data } = await httpClient.get<GetServicesResponse>('/services', {
    params: {
      name,
      stackId,
    },
  });
  return data;
};
