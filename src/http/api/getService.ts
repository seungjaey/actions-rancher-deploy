import type { AxiosInstance } from 'axios';

interface GetServiceResponse {
  id: string;
  type: string;
  links: {
    self: string;
    account: string;
    consumedbyservices: string;
    consumedservices: string;
    instances: string;
    networkDrivers: string;
    serviceExposeMaps: string;
    serviceLogs: string;
    stack: string;
    storageDrivers: string;
    containerStats: string;
  };
  actions: {
    upgrade: string;
    restart: string;
    update: string;
    remove: string;
    deactivate: string;
    removeservicelink: string;
    addservicelink: string;
    setservicelinks: string;
  };
  baseType: string;
  name: string;
  state: string;
  accountId: string;
  assignServiceIpAddress: boolean;
  createIndex: number;
  created: string;
  createdTS: number;
  currentScale: number;
  description: any;
  externalId: any;
  fqdn: any;
  healthState: string;
  instanceIds: string[];
  kind: string;
  launchConfig: {
    type: string;
    blkioWeight: any;
    capAdd: any[];
    capDrop: any[];
    cgroupParent: any;
    count: any;
    cpuCount: any;
    cpuPercent: any;
    cpuPeriod: any;
    cpuQuota: any;
    cpuRealtimePeriod: any;
    cpuRealtimeRuntime: any;
    cpuSet: any;
    cpuSetMems: any;
    cpuShares: any;
    dataVolumes: any[];
    dataVolumesFrom: any[];
    description: any;
    devices: any[];
    diskQuota: any;
    dns: any[];
    dnsSearch: any[];
    domainName: any;
    environment: {
      RUN_STAGE: string;
      STAGE: string;
    };
    healthInterval: any;
    healthRetries: any;
    healthTimeout: any;
    hostname: any;
    imageUuid: string;
    instanceTriggeredStop: string;
    ioMaximumBandwidth: any;
    ioMaximumIOps: any;
    ip: any;
    ip6: any;
    ipcMode: any;
    isolation: any;
    kernelMemory: any;
    kind: string;
    labels: {
      'traefik.backend': string;
      'traefik.enable': string;
      'traefik.frontend.rule': string;
      'traefik.port': string;
      'io.rancher.scheduler.affinity:host_label': string;
    };
    logConfig: {
      type: string;
      config: {};
      driver: any;
    };
    memory: any;
    memoryMb: any;
    memoryReservation: any;
    memorySwap: any;
    memorySwappiness: any;
    milliCpuReservation: any;
    networkMode: string;
    oomScoreAdj: any;
    pidMode: any;
    pidsLimit: any;
    ports: any[];
    privileged: boolean;
    publishAllPorts: boolean;
    readOnly: boolean;
    requestedIpAddress: any;
    runInit: boolean;
    secrets: any[];
    shmSize: any;
    startOnCreate: boolean;
    stdinOpen: boolean;
    stopSignal: any;
    stopTimeout: any;
    system: boolean;
    tty: boolean;
    user: any;
    userdata: any;
    usernsMode: any;
    uts: any;
    version: string;
    volumeDriver: any;
    workingDir: any;
    dataVolumesFromLaunchConfigs: any[];
    networkLaunchConfig: any;
    vcpu: number;
    drainTimeoutMs: number;
  };
  lbConfig: any;
  linkedServices: any;
  metadata: {
    'io.rancher.service.hash': string;
  };
  publicEndpoints: any;
  removed: any;
  retainIp: any;
  scale: number;
  scalePolicy: any;
  secondaryLaunchConfigs: any[];
  selectorContainer: any;
  selectorLink: any;
  stackId: string;
  startOnCreate: boolean;
  system: boolean;
  transitioning: string;
  transitioningMessage: any;
  transitioningProgress: any;
  upgrade: {
    type: string;
    inServiceStrategy: {
      type: string;
      batchSize: number;
      intervalMillis: number;
      launchConfig: {
        type: string;
        blkioWeight: any;
        capAdd: any[];
        capDrop: any[];
        cgroupParent: any;
        count: any;
        cpuCount: any;
        cpuPercent: any;
        cpuPeriod: any;
        cpuQuota: any;
        cpuRealtimePeriod: any;
        cpuRealtimeRuntime: any;
        cpuSet: any;
        cpuSetMems: any;
        cpuShares: any;
        dataVolumes: any[];
        dataVolumesFrom: any[];
        description: any;
        devices: any[];
        diskQuota: any;
        dns: any[];
        dnsSearch: any[];
        domainName: any;
        environment: {
          RUN_STAGE: string;
          STAGE: string;
        };
        healthInterval: any;
        healthRetries: any;
        healthTimeout: any;
        hostname: any;
        imageUuid: string;
        instanceTriggeredStop: string;
        ioMaximumBandwidth: any;
        ioMaximumIOps: any;
        ip: any;
        ip6: any;
        ipcMode: any;
        isolation: any;
        kernelMemory: any;
        kind: string;
        labels: {
          'traefik.backend': string;
          'traefik.enable': string;
          'traefik.frontend.rule': string;
          'traefik.port': string;
          'io.rancher.scheduler.affinity:host_label': string;
        };
        logConfig: {
          type: string;
          config: {};
          driver: any;
        };
        memory: any;
        memoryMb: any;
        memoryReservation: any;
        memorySwap: any;
        memorySwappiness: any;
        milliCpuReservation: any;
        networkMode: string;
        oomScoreAdj: any;
        pidMode: any;
        pidsLimit: any;
        ports: any[];
        privileged: boolean;
        publishAllPorts: boolean;
        readOnly: boolean;
        requestedIpAddress: any;
        runInit: boolean;
        secrets: any[];
        shmSize: any;
        startOnCreate: boolean;
        stdinOpen: boolean;
        stopSignal: any;
        stopTimeout: any;
        system: boolean;
        tty: boolean;
        user: any;
        userdata: any;
        usernsMode: any;
        uts: any;
        version: string;
        volumeDriver: any;
        workingDir: any;
        dataVolumesFromLaunchConfigs: any[];
        networkLaunchConfig: any;
        vcpu: number;
        drainTimeoutMs: number;
      };
      previousLaunchConfig: {
        type: string;
        blkioWeight: any;
        capAdd: any[];
        capDrop: any[];
        cgroupParent: any;
        count: any;
        cpuCount: any;
        cpuPercent: any;
        cpuPeriod: any;
        cpuQuota: any;
        cpuRealtimePeriod: any;
        cpuRealtimeRuntime: any;
        cpuSet: any;
        cpuSetMems: any;
        cpuShares: any;
        dataVolumes: any[];
        dataVolumesFrom: any[];
        description: any;
        devices: any[];
        diskQuota: any;
        dns: any[];
        dnsSearch: any[];
        domainName: any;
        environment: {
          RUN_STAGE: string;
          STAGE: string;
        };
        healthInterval: any;
        healthRetries: any;
        healthTimeout: any;
        hostname: any;
        imageUuid: string;
        instanceTriggeredStop: string;
        ioMaximumBandwidth: any;
        ioMaximumIOps: any;
        ip: any;
        ip6: any;
        ipcMode: any;
        isolation: any;
        kernelMemory: any;
        kind: string;
        labels: {
          'traefik.backend': string;
          'traefik.enable': string;
          'traefik.frontend.rule': string;
          'traefik.port': string;
          'io.rancher.scheduler.affinity:host_label': string;
        };
        logConfig: {
          type: string;
          config: {};
          driver: any;
        };
        memory: any;
        memoryMb: any;
        memoryReservation: any;
        memorySwap: any;
        memorySwappiness: any;
        milliCpuReservation: any;
        networkMode: string;
        oomScoreAdj: any;
        pidMode: any;
        pidsLimit: any;
        ports: any[];
        privileged: boolean;
        publishAllPorts: boolean;
        readOnly: boolean;
        requestedIpAddress: any;
        runInit: boolean;
        secrets: any[];
        shmSize: any;
        startOnCreate: boolean;
        stdinOpen: boolean;
        stopSignal: any;
        stopTimeout: any;
        system: boolean;
        tty: boolean;
        user: any;
        userdata: any;
        usernsMode: any;
        uts: any;
        version: string;
        volumeDriver: any;
        workingDir: any;
        dataVolumesFromLaunchConfigs: any[];
        networkLaunchConfig: any;
        vcpu: number;
        drainTimeoutMs: number;
      };
      previousSecondaryLaunchConfigs: any[];
      secondaryLaunchConfigs: any[];
      startFirst: boolean;
    };
    toServiceStrategy: any;
  };
  uuid: string;
  vip: any;
}
export const getService = async (httpClient: AxiosInstance, serviceId: string): Promise<GetServiceResponse> => {
  const { data } = await httpClient.get<GetServiceResponse>(`/services/${serviceId}`);
  return data;
};

// TODO: Reuse Function signature
export const getServiceState = async (httpClient: AxiosInstance, serviceId: string): Promise<string> => {
  const service = await getService(httpClient, serviceId);
  return service.state;
};
